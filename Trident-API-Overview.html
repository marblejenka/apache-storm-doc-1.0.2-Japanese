<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>Trident API Overview</title>

    <!-- Bootstrap core CSS -->
    <link href="./assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="./assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="http://fortawesome.github.io/Font-Awesome/assets/font-awesome/css/font-awesome.css">
    <link href="./css/style.css" rel="stylesheet">
    <link href="./assets/css/owl.theme.css" rel="stylesheet">
    <link href="./assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="./assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="./assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="./assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="./assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body>
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="./index.html"><img src="./images/logo.png" class="logo" /></a>
          </div>
          <div class="col-md-5">
            
              <h1>Version: 1.0.2-Japanese</h1>
            
          </div>
          <div class="col-md-2">
            <a href="http://storm.apache.org/downloads.html" class="btn-std btn-block btn-download">Download</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="./index.html" id="home">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" id="contribute">Community <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="./Contributing-to-Storm.html">Contributing</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">Trident API Overview</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<p>Tridentの中核となるデータモデルは、一連のバッチとして処理される&quot;Stream&quot;です。ストリームはクラスタ内のノード間で分割され、ストリームに適用される操作は各パーティション間で並列に適用されます。</p>

<p>Tridentには5種類の操作があります:</p>

<ol>
<li>各パーティションローカルに適用され、ネットワーク転送を行わない操作</li>
<li>ストリームを再分割するが、コンテンツを変更しない再分割操作(ネットワーク転送を伴う)</li>
<li>操作の一部としてネットワーク転送を行う集約操作</li>
<li>グループ化されたストリームに対する操作</li>
<li>マージと結合</li>
</ol>

<h2 id="partition-local-operations">Partition-local operations</h2>

<p>パーティションローカルな操作はネットワーク転送を伴わず、各バッチのパーティションに独立して適用されます。</p>

<h3 id="functions">Functions</h3>

<p>関数は入力フィールドの集合を取り込み、出力としてゼロ個以上のタプルをemitします。出力タプルのフィールドは、ストリーム内の元の入力タプルに追加されます。関数がタプルをemitしない場合、元の入力タプルはフィルタされて取り除かれます。それ以外の場合、入力タプルは出力タプルごとに複製されます。以下の関数があるとします:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFunction</span> <span class="kd">extends</span> <span class="n">BaseFunction</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>ここで、変数&quot;mystream&quot;に、[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]というフィールドを持つストリームが次のタプルであるとします:</p>
<div class="highlight"><pre><code class="language-" data-lang="">[1, 2, 3]
[4, 1, 6]
[3, 0, 8]
</code></pre></div>
<p>以下のコードを実行すると:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"b"</span><span class="o">),</span> <span class="k">new</span> <span class="n">MyFunction</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"d"</span><span class="o">)))</span>
</code></pre></div>
<p>結果のタプルにはフィールド[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]があり、次のようになります:</p>
<div class="highlight"><pre><code class="language-" data-lang="">[1, 2, 3, 0]
[1, 2, 3, 1]
[4, 1, 6, 0]
</code></pre></div>
<h3 id="filters">Filters</h3>

<p>フィルタはタプルを入力として受け取り、そのタプルを保持するかどうかを決定します。以下のフィルタがあったとします:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFilter</span> <span class="kd">extends</span> <span class="n">BaseFilter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isKeep</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tuple</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>ここで、フィールド[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]を持つ以下のタプルがあるとします:</p>
<div class="highlight"><pre><code class="language-" data-lang="">[1, 2, 3]
[2, 1, 1]
[2, 3, 4]
</code></pre></div>
<p>以下のコードを実行すると:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">MyFilter</span><span class="o">())</span>
</code></pre></div>
<p>結果のタプルは次のようになります:</p>
<div class="highlight"><pre><code class="language-" data-lang="">[1, 2, 3]
</code></pre></div>
<h3 id="map-and-flatmap">map and flatMap</h3>

<p><code>map</code>は与えられたマッピング関数をタプルのストリームに適用した結果からなるストリームを返します。
これは、1対1の変換をタプルに適用するために使用できます。</p>

<p>たとえば、単語のストリームがあり、それを大文字の単語のストリームに変換したい場合は、
次のようにマッピング関数を定義することができます。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UpperCase</span> <span class="kd">extends</span> <span class="n">MapFunction</span> <span class="o">{</span>
 <span class="nd">@Override</span>
 <span class="kd">public</span> <span class="n">Values</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">return</span> <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">toUpperCase</span><span class="o">());</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>次に、マッピング関数をストリームに適用して大文字のストリームを生成することができます。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">UpperCase</span><span class="o">())</span>
</code></pre></div>
<p><code>flatMap</code>は<code>map</code>に似ていますが、ストリームの値に一対多変換を適用するという効果があります。
結果として得られた要素を新しいストリームに平坦化します。</p>

<p>たとえば、文のストリームがあり、それを単語のストリームに変換したい場合は、
次のようにflatMap関数を定義することができます、</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Split</span> <span class="kd">extends</span> <span class="n">FlatMapFunction</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Values</span><span class="o">&gt;</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Values</span><span class="o">&gt;</span> <span class="n">valuesList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">input</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">valuesList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">valuesList</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>flatMap関数を文のストリームに適用して単語のストリームを生成し、</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Split</span><span class="o">())</span>
</code></pre></div>
<p>もちろん、これらの操作は連鎖させることができるので、次のように文のストリームから大文字になった単語のストリームを得ることができます、</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Split</span><span class="o">()).</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">UpperCase</span><span class="o">())</span>
</code></pre></div>
<h3 id="peek">peek</h3>

<p><code>peek</code>を使って、それぞれのTridentタプルがストリームを流れるときに、追加のアクションを実行することができます。
これは、パイプラインの特定のポイントを流れていくタプルをデバッグするのに便利です。</p>

<p>例えば、以下のコードは<code>groupBy</code>に渡される前に単語を大文字に変換した結果を出力します</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"> <span class="n">mystream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Split</span><span class="o">()).</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">UpperCase</span><span class="o">())</span>
         <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="k">new</span> <span class="n">Consumer</span><span class="o">()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
                <span class="o">}</span>
         <span class="o">})</span>
         <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
         <span class="o">.</span><span class="na">persistentAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">MemoryMapState</span><span class="o">.</span><span class="na">Factory</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<h3 id="min-and-minby">min and minBy</h3>

<p><code>min</code>および<code>minBy</code>演算は、Tridentのストリームにおけるタプルのバッチについての各パーティションにおける最小値を返します。</p>

<p>Tridentのストリームにフィールド[&quot;device-id&quot;, &quot;count&quot;]と次のタプルのパーティションが含まれているとします</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
[123, 2]
[113, 54]
[23,  28]
[237, 37]
[12,  23]
[62,  17]
[98,  42]

Partition 1:
[64,  18]
[72,  54]
[2,   28]
[742, 71]
[98,  45]
[62,  12]
[19,  174]


Partition 2:
[27,  94]
[82,  23]
[9,   86]
[53,  71]
[74,  37]
[51,  49]
[37,  98]

</code></pre></div>
<p><code>minBy</code>演算は、上記のようなタプルのストリームに対して適用することができ、その結果、各パーティション内の最小のcountフィールドの値を持つタプルがemitされます。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">  <span class="n">mystream</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<p>前述のパーティションについてのコードの結果は次のとおりです:</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
[123, 2]


Partition 1:
[62,  12]


Partition 2:
[82,  23]

</code></pre></div>
<p>ストリームにおける他の<code>min</code>および<code>minBy</code>操作を見ることができます</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">      <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stream</span> <span class="nf">minBy</span><span class="o">(</span><span class="n">String</span> <span class="n">inputFieldName</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> 
      <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">min</span><span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> 
</code></pre></div>
<p>下の例は、タプル上のそれぞれのコンパレータを使用してこれらのAPIを使用して最小値を見つける方法を示しています。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
        <span class="n">FixedBatchSpout</span> <span class="n">spout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FixedBatchSpout</span><span class="o">(</span><span class="n">allFields</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">Vehicle</span><span class="o">.</span><span class="na">generateVehicles</span><span class="o">(</span><span class="mi">20</span><span class="o">));</span>

        <span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>
        <span class="n">Stream</span> <span class="n">vehiclesStream</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">).</span>
                <span class="n">each</span><span class="o">(</span><span class="n">allFields</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"##### vehicles"</span><span class="o">));</span>

        <span class="n">Stream</span> <span class="n">slowVehiclesStream</span> <span class="o">=</span>
                <span class="n">vehiclesStream</span>
                        <span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="k">new</span> <span class="n">SpeedComparator</span><span class="o">())</span> <span class="c1">// Comparator w.r.t speed on received tuple.</span>
                        <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">vehicleField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"#### slowest vehicle"</span><span class="o">));</span>

        <span class="n">vehiclesStream</span>
                <span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="n">Vehicle</span><span class="o">.</span><span class="na">FIELD_NAME</span><span class="o">,</span> <span class="k">new</span> <span class="n">EfficiencyComparator</span><span class="o">())</span> <span class="c1">// Comparator w.r.t efficiency on received tuple.</span>
                <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">vehicleField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"#### least efficient vehicle"</span><span class="o">));</span>

</code></pre></div>
<p>これらのAPIのアプリケーション例は、<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfDevicesTopology.java">TridentMinMaxOfDevicesTopology</a>と<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfVehiclesTopology.java">TridentMinMaxOfVehiclesTopology</a>にあります。</p>

<h3 id="max-and-maxby">max and maxBy</h3>

<p><code>max</code>と<code>maxBy</code>オペレーションは、Tridentのストリームにおけるタプルのバッチについて、各パーティションにおける最大値を返します。</p>

<p>Tridentのストリームには、上のセクションで説明したフィールド[&quot;device-id&quot;, &quot;count&quot;]が含まれているとします。</p>

<p><code>max</code>と<code>maxBy</code>演算は上記のようなタプルのストリームに適用することができ、その結果、各パーティションの<code>count</code>フィールドの最大値を持つタプルがemitされます。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">  <span class="n">mystream</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<p>前述のパーティションについてのコードの結果は次のとおりです:</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
[113, 54]


Partition 1:
[19,  174]


Partition 2:
[37,  98]

</code></pre></div>
<p>ストリーム上の他の<code>max</code>と<code>maxBy</code>関数を見ることができます</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
      <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stream</span> <span class="nf">maxBy</span><span class="o">(</span><span class="n">String</span> <span class="n">inputFieldName</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> 
      <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">max</span><span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> 

</code></pre></div>
<p>以下の例は、タプル上のそれぞれのコンパレータを使用してこれらのAPIを使用して最大値を見つける方法を示しています。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
        <span class="n">FixedBatchSpout</span> <span class="n">spout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FixedBatchSpout</span><span class="o">(</span><span class="n">allFields</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">Vehicle</span><span class="o">.</span><span class="na">generateVehicles</span><span class="o">(</span><span class="mi">20</span><span class="o">));</span>

        <span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>
        <span class="n">Stream</span> <span class="n">vehiclesStream</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">).</span>
                <span class="n">each</span><span class="o">(</span><span class="n">allFields</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"##### vehicles"</span><span class="o">));</span>

        <span class="n">vehiclesStream</span>
                <span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="k">new</span> <span class="n">SpeedComparator</span><span class="o">())</span> <span class="c1">// Comparator w.r.t speed on received tuple.</span>
                <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">vehicleField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"#### fastest vehicle"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">project</span><span class="o">(</span><span class="n">driverField</span><span class="o">)</span>
                <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">driverField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"##### fastest driver"</span><span class="o">));</span>

        <span class="n">vehiclesStream</span>
                <span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="n">Vehicle</span><span class="o">.</span><span class="na">FIELD_NAME</span><span class="o">,</span> <span class="k">new</span> <span class="n">EfficiencyComparator</span><span class="o">())</span> <span class="c1">// Comparator w.r.t efficiency on received tuple.</span>
                <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="n">vehicleField</span><span class="o">,</span> <span class="k">new</span> <span class="n">Debug</span><span class="o">(</span><span class="s">"#### most efficient vehicle"</span><span class="o">));</span>

</code></pre></div>
<p>これらのAPIのアプリケーション例は、<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfDevicesTopology.java">TridentMinMaxOfDevicesTopology</a>と<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentMinMaxOfVehiclesTopology.java">TridentMinMaxOfVehiclesTopology</a>にあります。</p>

<h3 id="windowing">Windowing</h3>

<p>Tridentストリームは、同じウィンドウとしてバッチ内のタプルを処理し、集計結果を次の操作にemitすることができます。
processing timeまたはタプルの数に基づく2種類のウィンドウ処理がサポートされています:</p>

<ol>
<li>Tumbling window</li>
<li>Sliding window</li>
</ol>

<h4 id="tumbling-window">Tumbling window</h4>

<p>タプルは、processing timeまたはカウントに基づいて1つのウィンドウにグループ化されます。どのタプルも1つのウィンドウにしか属しません。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
    <span class="cm">/**
     * Returns a stream of tuples which are aggregated results of a tumbling window with every {@code windowCount} of tuples.
     */</span>
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">tumblingWindow</span><span class="o">(</span><span class="kt">int</span> <span class="n">windowCount</span><span class="o">,</span> <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span>
                                      <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span> <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">);</span>

    <span class="cm">/**
     * Returns a stream of tuples which are aggregated results of a window that tumbles at duration of {@code windowDuration}
     */</span>
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">tumblingWindow</span><span class="o">(</span><span class="n">BaseWindowedBolt</span><span class="o">.</span><span class="na">Duration</span> <span class="n">windowDuration</span><span class="o">,</span> <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span>
                                     <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span> <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">);</span>

</code></pre></div>
<h4 id="sliding-window">Sliding window</h4>

<p>タプルは、スライディング間隔ごとにウィンドウとウィンドウのスライドにグループ化されます。タプルは複数のウィンドウに属することができます。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
    <span class="cm">/**
     * Returns a stream of tuples which are aggregated results of a sliding window with every {@code windowCount} of tuples
     * and slides the window after {@code slideCount}.
     */</span>
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">slidingWindow</span><span class="o">(</span><span class="kt">int</span> <span class="n">windowCount</span><span class="o">,</span> <span class="kt">int</span> <span class="n">slideCount</span><span class="o">,</span> <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span>
                                      <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span> <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">);</span>

    <span class="cm">/**
     * Returns a stream of tuples which are aggregated results of a window which slides at duration of {@code slidingInterval}
     * and completes a window at {@code windowDuration}
     */</span>
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">slidingWindow</span><span class="o">(</span><span class="n">BaseWindowedBolt</span><span class="o">.</span><span class="na">Duration</span> <span class="n">windowDuration</span><span class="o">,</span> <span class="n">BaseWindowedBolt</span><span class="o">.</span><span class="na">Duration</span> <span class="n">slidingInterval</span><span class="o">,</span>
                                    <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span> <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">);</span>
</code></pre></div>
<p>タンブリングやスライディングウィンドウの例は、<a href="Windowing.html">ここ</a>にあります</p>

<h4 id="common-windowing-api">Common windowing API</h4>

<p>以下は、サポートされているすべてのウィンドウ設定に対して<code>WindowConfig</code>をとる一般的なウィンドウAPIです。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
    <span class="kd">public</span> <span class="n">Stream</span> <span class="nf">window</span><span class="o">(</span><span class="n">WindowConfig</span> <span class="n">windowConfig</span><span class="o">,</span> <span class="n">WindowsStoreFactory</span> <span class="n">windowStoreFactory</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">inputFields</span><span class="o">,</span>
                         <span class="n">Aggregator</span> <span class="n">aggregator</span><span class="o">,</span> <span class="n">Fields</span> <span class="n">functionFields</span><span class="o">)</span>

</code></pre></div>
<p><code>windowConfig</code>は、以下のいずれかになります。</p>

<ul>
<li><code>SlidingCountWindow.of(int windowCount, int slidingCount)</code></li>
<li><code>SlidingDurationWindow.of(BaseWindowedBolt.Duration windowDuration, BaseWindowedBolt.Duration slidingDuration)</code></li>
<li><code>TumblingCountWindow.of(int windowLength)</code></li>
<li><code>TumblingDurationWindow.of(BaseWindowedBolt.Duration windowLength)</code></li>
</ul>

<p>トライデントのウィンドウAPIには、受け取ったタプルと集計値を格納するための<code>WindowsStoreFactory</code>が必要です 現在、HBaseについての基本的な実装は <code>HBaseWindowsStoreFactory</code>で与えられています。これらは、それぞれのユースケースに対応するためにさらに拡張することができます。
ウィンドウ処理に<code>HBaseWindowStoreFactory</code>を使用する例を以下に示します。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">
    <span class="c1">// window-state table should already be created with cf:tuples column</span>
    <span class="n">HBaseWindowsStoreFactory</span> <span class="n">windowStoreFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HBaseWindowsStoreFactory</span><span class="o">(</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;(),</span> <span class="s">"window-state"</span><span class="o">,</span> <span class="s">"cf"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">),</span> <span class="s">"tuples"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">));</span>
    <span class="n">FixedBatchSpout</span> <span class="n">spout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FixedBatchSpout</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span> <span class="mi">3</span><span class="o">,</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="s">"the cow jumped over the moon"</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="s">"the man went to the store and bought some candy"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="s">"four score and seven years ago"</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Values</span><span class="o">(</span><span class="s">"how many apples can you eat"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="s">"to be or not to be the person"</span><span class="o">));</span>
    <span class="n">spout</span><span class="o">.</span><span class="na">setCycle</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

    <span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>

    <span class="n">Stream</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">).</span><span class="na">parallelismHint</span><span class="o">(</span><span class="mi">16</span><span class="o">).</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingCountWindow</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1000</span><span class="o">),</span> <span class="n">windowStoreFactory</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">),</span> <span class="k">new</span> <span class="n">CountAsAggregator</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="k">new</span> <span class="n">Consumer</span><span class="o">()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Received tuple: [{}]"</span><span class="o">,</span> <span class="n">input</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>

    <span class="n">StormTopology</span> <span class="n">stormTopology</span> <span class="o">=</span>  <span class="n">topology</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>

</code></pre></div>
<p>このセクションの上記すべてのAPIの詳細な説明は、<a href="javadocs/org/apache/storm/trident/Stream.html">こちら</a>にあります</p>

<h4 id="example-applications">Example applications</h4>

<p>これらのAPIのサンプルアプリケーションは、<a href="http://github.com/apache/storm/blob/1.x-branch/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentHBaseWindowingStoreTopology.java">TridentHBaseWindowingStoreTopology</a>と<a href="http://github.com/apache/storm/blob/1.x-branch/examples/storm-starter/src/jvm/org/apache/storm/starter/trident/TridentWindowingInmemoryStoreTopology.java">TridentWindowingInmemoryStoreTopology</a>にあります</p>

<h3 id="partitionaggregate">partitionAggregate</h3>

<p>partitionAggregateは、タプルのバッチの各パーティションで関数を実行します。functionとは異なり、partitionAggregateによってemitされたタプルは、与えられた入力タプルを置き換えます。この例を考えてみましょう:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">partitionAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"b"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sum"</span><span class="o">))</span>
</code></pre></div>
<p>入力ストリームにフィールド[&quot;a&quot;, &quot;b&quot;]と以下のタプルのパーティションが含まれているとします:</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
["a", 1]
["b", 2]

Partition 1:
["a", 3]
["c", 8]

Partition 2:
["e", 1]
["d", 9]
["d", 10]
</code></pre></div>
<p>そのコードの出力ストリームには、&quot;sum&quot;という1つのフィールドを持つこれらのタプルが含まれます:</p>
<div class="highlight"><pre><code class="language-" data-lang="">Partition 0:
[3]

Partition 1:
[11]

Partition 2:
[20]
</code></pre></div>
<p>aggregatorを定義するためのインターフェースには、次の3つのがあります: CombinerAggregator、ReducerAggregator、およびAggregatorです。</p>

<p>CombinerAggregatorのインターフェイスは次のとおりです:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CombinerAggregator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">init</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">);</span>
    <span class="n">T</span> <span class="nf">combine</span><span class="o">(</span><span class="n">T</span> <span class="n">val1</span><span class="o">,</span> <span class="n">T</span> <span class="n">val2</span><span class="o">);</span>
    <span class="n">T</span> <span class="nf">zero</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>CombinerAggregatorは、出力として単一のフィールドを持つ単一のタプルを返します。CombinerAggregatorsは各入力タプルに対してinit関数を実行し、combine関数を使用して1つの値が残るまで値をcombineします。パーティションにタプルがない場合、CombinerAggregatorはゼロ関数の出力をemitします。たとえば、Countの実装は次のとおりです:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Count</span> <span class="kd">implements</span> <span class="n">CombinerAggregator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">init</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">combine</span><span class="o">(</span><span class="n">Long</span> <span class="n">val1</span><span class="o">,</span> <span class="n">Long</span> <span class="n">val2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">val1</span> <span class="o">+</span> <span class="n">val2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">zero</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0L</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>CombinerAggregatorの利点は、partitionAggregateではなくaggregateメソッドで使用するときに見られます。その場合、Tridentは、ネットワーク上でタプルを転送する前に、部分集計を実行することによって計算を自動的に最適化します。</p>

<p>ReducerAggregatorには、次のインタフェースがあります:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ReducerAggregator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">init</span><span class="o">();</span>
    <span class="n">T</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">T</span> <span class="n">curr</span><span class="o">,</span> <span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>ReducerAggregatorはinitで初期値を生成し、各入力タプルに対してその値を反復処理して、単一の値を出力として持つ単一のタプルを生成します。たとえば、CountをReducerAggregatorとして定義する方法は次のとおりです:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Count</span> <span class="kd">implements</span> <span class="n">ReducerAggregator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0L</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Long</span> <span class="n">curr</span><span class="o">,</span> <span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">curr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>ReducerAggregatorは、後で見るように、persistentAggregateとともに使用することもできます。</p>

<p>集約を実行するための最も一般的なインターフェースは、次のようなAggregatorです:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Aggregator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Operation</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">init</span><span class="o">(</span><span class="n">Object</span> <span class="n">batchId</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">aggregate</span><span class="o">(</span><span class="n">T</span> <span class="n">state</span><span class="o">,</span> <span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">complete</span><span class="o">(</span><span class="n">T</span> <span class="n">state</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>Aggregatorは、任意の数のフィールドを持つ任意の数のタプルをemitできます。実行中の任意の時点でタプルをemitできます。Aggregatorは次のように実行されます:</p>

<ol>
<li>バッチを処理する前にinitメソッドが呼び出されます。initの戻り値は、集約の状態を表すObjectであり、aggregateメソッドおよびcompleteメソッドに渡されます。</li>
<li>aggregateメソッドは、バッチパーティション内の各入力タプルに対して呼び出されます。このメソッドは状態を更新することができ、また、タプルをemitすることもできます。</li>
<li>completeメソッドは、バッチパーティションのすべてのタプルがaggregateによって処理されたときに呼び出されます。</li>
</ol>

<p>CountをAggregatorとして実装する方法は次のとおりです:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountAgg</span> <span class="kd">extends</span> <span class="n">BaseAggregator</span><span class="o">&lt;</span><span class="n">CountState</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CountState</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">CountState</span> <span class="nf">init</span><span class="o">(</span><span class="n">Object</span> <span class="n">batchId</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CountState</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">aggregate</span><span class="o">(</span><span class="n">CountState</span> <span class="n">state</span><span class="o">,</span> <span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">state</span><span class="o">.</span><span class="na">count</span><span class="o">+=</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">complete</span><span class="o">(</span><span class="n">CountState</span> <span class="n">state</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">count</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>複数のaggregatorを同時に実行したい場合もあります。これは連鎖と呼ばれ、次のように実行できます:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">chainedAgg</span><span class="o">()</span>
        <span class="o">.</span><span class="na">partitionAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">partitionAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"b"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Sum</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sum"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">chainEnd</span><span class="o">()</span>
</code></pre></div>
<p>このコードは、各パーティションのCountおよびSum aggregatorを実行します。出力には、フィールド[&quot;count&quot;, &quot;sum&quot;]を持つ単一タプルが含まれます。</p>

<h3 id="statequery-and-partitionpersist">stateQuery and partitionPersist</h3>

<p>stateQueryおよびpartitionPersistは、それぞれ状態のソースをクエリおよび更新します。<a href="Trident-state.html">Trident state doc</a>で使用方法を読むことができます。</p>

<h3 id="projection">projection</h3>

<p>Streamの射影では、操作で指定されたフィールドのみが保持されます。フィールド[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]を持つストリームがあり、このコードを実行した場合:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">project</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">))</span>
</code></pre></div>
<p>出力ストリームにはフィールド[&quot;b&quot;, &quot;d&quot;]のみが含まれます。</p>

<h2 id="repartitioning-operations">Repartitioning operations</h2>

<p>再分割操作では、タプルがタスク間でどのように分割されるかについて変更する関数が実行されます。パーティションの数は、パーティション分割の結果として変更することもできます(たとえば、再分割後のparallelism hintが大きい場合など)。再パーティションにはネットワーク転送が必要です。再分割ができる関数は次のとおりです:</p>

<ol>
<li>shuffle: ランダムラウンドロビンアルゴリズムを使用して、タプルをすべてのターゲットパーティションに均等に再分配する</li>
<li>broadcast: すべてのタプルがすべてのターゲットパーティションに複製されます。これはDRPCで役立ちます - たとえば、データのすべてのパーティションでstateQueryを実行する必要がある場合などです。</li>
<li>partitionBy: partitionByはフィールドの集合を取り込み、そのフィールドの集合に基づいてセマンティクパーティショニングを行います。 フィールドはハッシュ化され、そのmod値でターゲットパーティションを選択します。partitionByは、同じフィールドの集合が常に同じターゲットパーティションに移動することを保証します。</li>
<li>global: すべてのタプルは同じパーティションに送られます ストリーム内のすべてのバッチに対して同じパーティションが選択されます。</li>
<li>batchGlobal: バッチ内のすべてのタプルが同じパーティションに送信されます。ストリーム内のさまざまなバッチが異なるパーティションに移動することがあります。</li>
<li>partition: このメソッドは、org.apache.storm.grouping.CustomStreamGroupingを実装するカスタムパーティショニング関数を取ります</li>
</ol>

<h2 id="aggregation-operations">Aggregation operations</h2>

<p>Tridentには、Streamで集計を実行するためのaggregateおよびpersistentAggregateメソッドがあります。aggregateはストリームの各バッチで独立して実行される一方で、persistentAggregateはストリーム内のすべてのバッチのすべてのタプルを集約し、その結果を状態のソースに格納します。</p>

<p>Stream上で集約を実行すると、グローバルな集計が行われます。ReducerAggregatorまたはAggregatorを使用すると、ストリームは最初に単一のパーティションに再分割され、そのパーティションで集約関数が実行されます。一方、CombinerAggregatorを使用する場合は、最初にTridentが各パーティションの部分集計を計算し、その後、単一のパーティションに再分割し、ネットワーク転送後に集約を完了します。CombinerAggregatorの方がはるかに効率的で、可能な限り使用するべきです。</p>

<p>aggregateを使用してバッチのグローバルなカウントを取得する例を次に示します:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mystream</span><span class="o">.</span><span class="na">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<p>partitionAggregateと同様に、aggregateのaggregatorは連鎖できます。ただし、CombinerAggregatorを非CombinerAggregatorと連鎖させると、Tridentは部分集計の最適化を行うことができません。</p>

<p><a href="Trident-state.html">Trident state doc</a>で、persistentAggregateの使用方法の詳細を読むことができます。</p>

<h2 id="operations-on-grouped-streams">Operations on grouped streams</h2>

<p>groupBy操作は、指定されたフィールドでpartitionByを実行してストリームを再分割し、その後、各パーティション内でグループ化するフィールドが等しいタプルをグループ化します。たとえば、groupBy操作の例を次に示します。</p>

<p><img src="images/grouping.png" alt="Grouping"></p>

<p>グループ化されたストリームでaggregatorを実行する場合、集約はバッチ全体ではなく各グループ内で実行されます。persistentAggregateはGroupedStreamで実行することもできます。その場合、結果は、キーをグループ化フィールドとして、<a href="http://github.com/apache/storm/blob/1.x-branch/storm-core/src/jvm/org/apache/storm/trident/state/map/MapState.java">MapState</a>に格納されます。persistentAggregateの詳細については、<a href="Trident-state.html">Trident state doc</a>を参照してください。</p>

<p>通常のストリームと同様に、グループ化されたストリームのaggregatorも連鎖できます。</p>

<h2 id="merges-and-joins">Merges and joins</h2>

<p>APIの最後の部分では、さまざまなストリームを結合しています。ストリームを結合する最も簡単な方法は、ストリームを1つのストリームにマージすることです。 TridentTopology#mergeメソッドを使用すると、次のようにすることができます:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">topology</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">stream1</span><span class="o">,</span> <span class="n">stream2</span><span class="o">,</span> <span class="n">stream3</span><span class="o">);</span>
</code></pre></div>
<p>Tridentは、新しくmergeされたストリームの出力フィールドを、引数の最初のストリームの出力フィールドを使って名前付けします。</p>

<p>ストリームを結合する別の方法は、Joinを使用する方法です。現在、SQLのような標準的な結合には有限の入力が必要です。このため、それは無限の流れでは意味をなしません。TridentのJoinは、Spoutから出てくる小さなバッチ内にのみ適用されます。</p>

<p>フィールド [&quot;key&quot;, &quot;val1&quot;, &quot;val2&quot;]を含むストリームと、[&quot;x&quot;, &quot;val1&quot;]含む別のストリームをJoinする例を次に示します:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">topology</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">stream1</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"key"</span><span class="o">),</span> <span class="n">stream2</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"x"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"key"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">));</span>
</code></pre></div>
<p>これは、それぞれのストリームの結合フィールドとして&quot;key&quot;と&quot;x&quot;を使用してstream1とstream2を結合します。次に、Tridentは、入力ストリームが重複するフィールド名を持つ可能性があるため、新しいストリームのすべての出力フィールドに名前を付ける必要があります。joinからemitされるタプルには、次のものが含まれます:</p>

<ol>
<li>まず、結合フィールドのリスト。この場合、&quot;key&quot;はstream1の&quot;key&quot;とstream2の&quot;x&quot;に対応しています。</li>
<li>次に、すべてのストリームからの非結合フィールドのリスト(ストリームが結合メソッドにどのように渡されたかの順になる)。この場合、&quot;a&quot;と&quot;b&quot;はstream1の&quot;val1&quot; と&quot;val2&quot;に対応し、&quot;c&quot;はstream2の&quot;val1&quot;に対応する。</li>
</ol>

<p>異なるSpoutから発生したストリーム間で結合が発生すると、それらのSpoutはどのようにバッチのemitについて同期されます。つまり、処理のバッチには双方のSpoutからのタプルが含まれます。</p>

<p>あなたは疑問に思うかもしれません - どうやって&quot;windowed join&quot;のようなことをしているか - 結合の片側からのタプルは、結合の反対側からのタプルの最後の1時間と結合されます。</p>

<p>これを行うには、partitionPersistとstateQueryを使用します。結合の一方の側からのタプルの最後の1時間は、結合フィールドをキーとした状態のソースに格納され、ローテーションされます。次に、stateQueryは、&quot;join&quot;を実行するために結合フィールドによって検索を行います。</p>



	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>Meetups</h5>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>About Storm</h5>
                    <p>Storm integrates with any queueing system and any database system. Storm's spout abstraction makes it easy to integrate a new queuing system. Likewise, integrating Storm with database systems is easy.</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>First Look</h5>
                    <ul class="footer-list">
                        <li><a href="./Rationale.html">Rationale</a></li>
                        <li><a href="./Tutorial.html">Tutorial</a></li>
                        <li><a href="./Setting-up-development-environment.html">Setting up development environment</a></li>
                        <li><a href="./Creating-a-new-Storm-project.html">Creating a new Storm project</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>Documentation</h5>
                    <ul class="footer-list">
                        <li><a href="./index.html">Index</a></li>
                        <li><a href="./javadocs/index.html">Javadoc</a></li>
                        <li><a href="./FAQ.html">FAQ</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr/>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">Copyright © 2015 <a href="http://www.apache.org">Apache Software Foundation</a>. All Rights Reserved. 
                    <br>Apache Storm, Apache, the Apache feather logo, and the Apache Storm project logos are trademarks of The Apache Software Foundation. 
                    <br>All other marks mentioned may be trademarks or registered trademarks of their respective owners.</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 

</body>

</html>

