<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <title>Trident State</title>

    <!-- Bootstrap core CSS -->
    <link href="./assets/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="./assets/css/bootstrap-theme.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link rel="stylesheet" href="http://fortawesome.github.io/Font-Awesome/assets/font-awesome/css/font-awesome.css">
    <link href="./css/style.css" rel="stylesheet">
    <link href="./assets/css/owl.theme.css" rel="stylesheet">
    <link href="./assets/css/owl.carousel.css" rel="stylesheet">
    <script type="text/javascript" src="./assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="./assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="./assets/js/owl.carousel.min.js"></script>
    <script type="text/javascript" src="./assets/js/storm.js"></script>
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body>
    <header>
  <div class="container-fluid">
     <div class="row">
          <div class="col-md-5">
            <a href="./index.html"><img src="./images/logo.png" class="logo" /></a>
          </div>
          <div class="col-md-5">
            
              <h1>Version: 1.0.2-Japanese</h1>
            
          </div>
          <div class="col-md-2">
            <a href="http://storm.apache.org/downloads.html" class="btn-std btn-block btn-download">Download</a>
          </div>
        </div>
    </div>
</header>
<!--Header End-->
<!--Navigation Begin-->
<div class="navbar" role="banner">
  <div class="container-fluid">
      <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
        <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
              <li><a href="./index.html" id="home">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" id="contribute">Community <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="./Contributing-to-Storm.html">Contributing</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
    </div>
</div>



    <div class="container-fluid">
    <h1 class="page-title">Trident State</h1>
          <div class="row">
           	<div class="col-md-12">
	             <!-- Documentation -->

<p class="post-meta"></p>

<p>Tridentには、ステートフルなソースからの読み書き用のfirst-classの抽象があります。状態は、メモリ内に保持されつつHDFSによってバックアップされるなど、トポロジの内部にあってもよく、MemcachedまたはCassandraのようなデータベースに外部的に格納されていても構いません。どちらの場合でもTrident APIに違いはありません。</p>

<p>Tridentは、フォールトトレラントな方法で状態を管理し、再試行や障害が発生しても状態の更新が冪等であるようにします。これにより、各メッセージがどのようにexactly-onceに処理されるか、Tridentのトポロジについて推論することができます。</p>

<p>状態の更新は、さまざまなレベルのフォールトトレランスで行うことができます。それらについて考える前に、exactly-onceセマンティクスを達成するために必要な技を示す例を見てみましょう。ストリームの集計を行い、累積カウントをデータベースに格納したいとします。今は、カウントを表す単一の値をデータベースに格納し、新しいタプルを処理するたびにカウントを増やすとします。</p>

<p>障害が発生すると、タプルがリプレイされます。これは、状態の更新(または副作用があるもの)を行うときに問題を引き起こします - 以前にそのタプルに基づいて状態を正常に更新したことがあるかどうかわかりません。おそらく、あなたは前にそのタプルを処理したことがなかったはずで、その場合、カウントをインクリメントするべきです。おそらく、あなたはタプルを処理してカウントを増やすのに成功しましたが、タプルは別のステップで処理に失敗しました。この場合、カウントをインクリメントするべきではありません。または、おそらく前にそのタプルを見たことがありますが、データベースを更新するときにエラーが発生しました。この場合、データベースを更新する<em>べき</em>です。</p>

<p>このように、カウントをデータベースに格納するだけでは、このタプルが以前に処理されたかどうかはわかりません。正しい判断を下すためには、より多くの情報が必要です。 Tridentは、exactly-onceの処理セマンティクスを達成するのに十分な以下のセマンティクスを提供します:</p>

<ol>
<li>タプルは小さなバッチとして処理されます(<a href="Trident-tutorial.html">チュートリアル</a>を参照)</li>
<li>タプルの各バッチには、&quot;transaction id&quot; (txid)と呼ばれる一意のIDが与えられます。バッチが再生される場合、正確に同じtxidが与えられます。</li>
<li>状態更新は、バッチ間で順序付けされます。つまり、バッチ3の状態更新は、バッチ2の状態更新が成功するまで適用されません。</li>
</ol>

<p>これらのプリミティブを使用すると、状態の実装は、タプルのバッチが以前に処理されたかどうかを検出し、一貫した方法で状態を更新するための適切なアクションを実行できます。実行するアクションは、各バッチの内容について入力Spuutが提供する正確性のセマンティクスに依存します。フォールトトレランスに関するSpoutの種類は、&quot;non-transactional&quot;, &quot;transactional&quot;と&quot;opaque transactional&quot;の3種類があります。同様に、フォールトトレランスに関する状態の種類は、&quot;non-transactional&quot;, &quot;transactional&quot;と&quot;opaque transactional&quot;の3種類があります。それぞれのSpoutの種類を見て、どのような種類のフォールトトレランスでそれぞれを達成できるかを見てみましょう。</p>

<h2 id="transactional-spouts">Transactional spouts</h2>

<p>Tridentはタプルを小さなバッチとして処理し、各バッチには一意のトランザクションIDが与えられることを思い出してください。Spoutの特性は、各バッチに含まれているものについて保証できることによって変わります。transactional spoutには、次の特性があります:</p>

<ol>
<li>与えられたtxidのバッチは常に同じです。特定のtxidであるバッチのリプレイは、そのtxidに対してバッチが最初にemitされたときと同じ集合であるタプルを正確に扱います。</li>
<li>バッチ間にタプルの重複はありません(タプルはあるバッチまたはそれとは別のバッチにあり、決して複数にはありません)。</li>
<li>すべてのタプルはバッチに含まれます(スキップされるタプルはありません)</li>
</ol>

<p>これは分かりやすいSpoutの種類です。ストリームは決して変化しない固定のバッチに分割されています。storm-contribにはKafkaの<a href="http://github.com/apache/storm/tree/1.x-branch/external/storm-kafka/src/jvm/org/apache/storm/kafka/trident/TransactionalTridentKafkaSpout.java">transactional spoutの実装</a>があります。</p>

<p>あなたは疑問に思うかもしれません - どうして常にtransactional spoutを使用しないのか？それは簡単で理解しやすいです。1つの理由は、必ずしもフォールトトレラントでなければならないなわけではないからです。たとえば、TransactionalTridentKafkaSpoutの仕組みは、特定のtxidのバッチには、あるトピックについてのすべてのKafkaのパーティションから来るタプルを含んでいることを前提としています。一度バッチがemitされると、バッチが将来において再度emitされるたびに、transactional spoutのセマンティクスを満たすために全く同じ集合のタプルをemitする必要があります。TransactionalTridentKafkaSpoutからバッチがemitされ、バッチに対する処理に失敗し、同時にKafkaのノードの1つがダウンしたとします。これで、以前と同じバッチをリプレイすることができなくなり(ノードがダウンしてトピックの一部のパーティションが使用できなくなったため)、処理が停止します。</p>

<p>これは、&quot;opaque transactional&quot;Spoutが存在する理由です - ソースとなるノードが失われてもフォールトトレラントでありながら、exactly-onceの処理セマンティクスを実現できます。我々は次のセクションでそれらのSpoutをカバーします。</p>

<p>(注記 - Kafkaがレプリケーションをサポートすると、ノード障害に対してフォールトトレラントなtransactional spoutを持つことは可能ですが、その機能はまだ存在しません。)</p>

<p>&quot;opaque transactional&quot;なspoutについて見る前に、transactional spoutに対してexactly-onceのセマンティクスを持つState実装をどのように設計するかを見てみましょう。このStateの種類は&quot;transactional state&quot;と呼ばれ、与えられたtxidが常に同じタプルの集合に関連付けられているという事実を利用します。</p>

<p>トポロジが単語数を計算し、単語数をkey/valueデータベースに保存するとします。キーは単語になり、バリューにはカウントが含まれます。バリューに数だけを格納するだけでは、タプルのバッチを処理したかどうかを知るには不十分であることについて見てきました。代わりに、データベースにトランザクションIDとカウントをアトミックな値として格納することができます。その後、カウントを更新する際に、データベースのトランザクションIDと現在のバッチのトランザクションIDを比較すれば十分です。それらが同じであれば、更新をスキップします - 強い順序付けのため、データベースの値に現在のバッチの結果が含まれていることがわかります。それらが異なる場合は、カウントを増やします。このロジックは、txidのバッチは決して変更されないこと、また、Tridentが状態更新がバッチ間で順序付けされることを保証しているため成立します。</p>

<p>なぜこの設計が機能するか例で考えてみましょう。次のタプルのバッチで構成されるtxid 3を処理しているとします:</p>
<div class="highlight"><pre><code class="language-" data-lang="">["man"]
["man"]
["dog"]
</code></pre></div>
<p>データベースが現在、次のキーと値のバリューのペアを保持しているとします:</p>
<div class="highlight"><pre><code class="language-" data-lang="">man =&gt; [count=3, txid=1]
dog =&gt; [count=4, txid=3]
apple =&gt; [count=10, txid=2]
</code></pre></div>
<p>&quot;man&quot;に関連付けられたtxidはtxid 1です。現在のtxidは3であるため、処理しようとしているバッチのタプルはカウントに含まれていないことがわかります。このため、処理を続けて、カウントを2つ増やしてtxidを更新することができます。一方、&quot;dog&quot;のtxidは現在のtxidと同じです。したがって、現在のバッチからのインクリメントがデータベース内で&quot;dog&quot;キー用に既に含まれていることがわかります。したがって、アップデートをスキップすることができます。更新が完了すると、データベースは次のようになります:</p>
<div class="highlight"><pre><code class="language-" data-lang="">man =&gt; [count=5, txid=3]
dog =&gt; [count=4, txid=3]
apple =&gt; [count=10, txid=2]
</code></pre></div>
<p>では、opaque transactional spoutと、その種類のSpoutの状態を設計する方法を見てみましょう。</p>

<h2 id="opaque-transactional-spouts">Opaque transactional spouts</h2>

<p>前に説明したように、opaque transactional spoutは、タプルのバッチに対するtxidが一定のままであることを保証することはできません。opaque transactional spoutには、次の特性があります:</p>

<ol>
<li>すべてのタプルは、必ず1つのバッチで<em>正常に</em>処理されます。しかし、タプルが1つのバッチで処理できず、その後、後のバッチで処理に成功する可能性があります。</li>
</ol>

<p><a href="http://github.com/apache/storm/tree/1.x-branch/external/storm-kafka/src/jvm/org/apache/storm/kafka/trident/OpaqueTridentKafkaSpout.java">OpaqueTridentKafkaSpout</a>は、この特性を持ち、Kafkaのノードを失うことにフォールトトレラントなSpoutです。OpaqueTridentKafkaSpoutがバッチをemitするときはいつでも、最後のバッチがemitを完了したところからemitを開始します。これにより、タプルがスキップされたり、複数のバッチによって正常に処理されたりすることはありません。</p>

<p>opaque transactional spoutでは、データベース内のトランザクションIDが現在のバッチのトランザクションIDと同じであれば状態更新をスキップするトリックを使用することはもはや不可能です。これは、状態の更新の間にバッチが変更された可能性があるためです。</p>

<p>あなたができることは、より多くの状態をデータベースに格納することです。値とトランザクションIDをデータベースに格納するのではなく、値、トランザクションID、および直前の値をデータベースに格納します。再度、データベースにカウントを格納する例を使用してみましょう。バッチの部分カウントが&quot;2&quot;であり、状態更新を適用するときだとします。データベースの値が次のようになっているとします:</p>
<div class="highlight"><pre><code class="language-" data-lang=""><span class="p">{</span><span class="w"> </span><span class="err">value</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">4,</span><span class="w">
  </span><span class="err">prevValue</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">1,</span><span class="w">
  </span><span class="err">txid</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">2</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>現在のtxidが3で、データベース内のtxidと異なるとします。この場合、&quot;prevValue&quot;を&quot;value&quot;に設定し、部分カウントだけ&quot;value&quot;を増やして、txidを更新します。 新しいデータベース値は次のようになります:</p>
<div class="highlight"><pre><code class="language-" data-lang=""><span class="p">{</span><span class="w"> </span><span class="err">value</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">6,</span><span class="w">
  </span><span class="err">prevValue</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">4,</span><span class="w">
  </span><span class="err">txid</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">3</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>今度は、現在のtxidが2で、データベースの内容と同じであるとします。データベースの&quot;value&quot;には現在のバッチと同じtxidである前のバッチからの更新が含まれており、そのバッチは今回のバッチと異なる可能性があるので、以前のバッチによって適用された値を無視する必要があります。この場合、あなたの部分的なカウントによって &quot;prevValue&quot;をインクリメントして、新しい&quot;value&quot;を計算します。そして、データベースの値を次のように設定します:</p>
<div class="highlight"><pre><code class="language-" data-lang=""><span class="p">{</span><span class="w"> </span><span class="err">value</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">3,</span><span class="w">
  </span><span class="err">prevValue</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">1,</span><span class="w">
  </span><span class="err">txid</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">2</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>これは、Tridentによって提供されたバッチの強力な順序付けのために機能します。Tridentが状態更新のために新しいバッチに移動すると、それは決して前のバッチに戻ることはありません。また、opaque transactional spoutはバッチ間のオーバーラップがないことを保証しているので - 各タプルは1つのバッチで正常に処理されます - 前の値に基づいて安全に更新できます。</p>

<h2 id="non-transactional-spouts">Non-transactional spouts</h2>

<p>Non-transactional spoutは、各バッチの内容を保証するものではありません。したがって、at-most-onceで処理することがあります。この場合、失敗したバッチの後にタプルは再試行されません。または、タプルが複数のバッチで正常に処理される、at-least-onceで処理が行われる可能性があります。この種類のSpoutには、exactly-onceセマンティクスを達成する方法はありません。</p>

<h2 id="summary-of-spout-and-state-types">Summary of spout and state types</h2>

<p>以下の図は、Spout/Stateのどの組み合わせがexactly-onceのメッセージングセマンティクスを可能にするかを示しています:</p>

<p><img src="images/spout-vs-state.png" alt="Spouts vs States"></p>

<p>Opaque transactional stateはフォールトトレランス性が最も強力ですが、これはtxidと2つの値をデータベースに格納するコストがかかります。Transactional statesでは、データベース内の状態は少なくて済みますが、transactional spoutでしか動作しません。最後に、non-transactional stateはデータベース内の状態についての要求は最小ですが、exactly-onceのセマンティクスは実現できません。</p>

<p>選択すべきStateとSpoutの種類は、フォールトトレランスとストレージコストのトレードオフです。究極的に、アプリケーションの要件によって、どの組み合わせが適切かが決まります。</p>

<h2 id="state-apis">State APIs</h2>

<p>あなたは、exactly-onceのセマンティクスを達成するために必要なものの複雑さを見てきました。Tridentの素晴らしい点は、State内のすべてのフォールトトレランスロジックを内部化していることです - ユーザーは、txidの比較、データベース内への複数の値の格納などを扱う必要はありません。次のようなコードを書くことができます:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>        
<span class="n">TridentState</span> <span class="n">wordCounts</span> <span class="o">=</span>
      <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">)</span>
        <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">persistentAggregate</span><span class="o">(</span><span class="n">MemcachedState</span><span class="o">.</span><span class="na">opaque</span><span class="o">(</span><span class="n">serverLocations</span><span class="o">),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>                
        <span class="o">.</span><span class="na">parallelismHint</span><span class="o">(</span><span class="mi">6</span><span class="o">);</span>
</code></pre></div>
<p>opaque transactional stateを管理するために必要なすべてのロジックは、MemcachedState.opaque呼び出しで内部化されています。さらに、データベースへのラウンドトリップを最小限に抑えるために、更新は自動的にバッチ処理されます。</p>

<p>基底となるStateインターフェイスには2つのメソッドしかありません:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">beginCommit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">);</span> <span class="c1">// can be null for things like partitionPersist occurring off a DRPC stream</span>
    <span class="kt">void</span> <span class="nf">commit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>状態の更新が開始されたときや、状態の更新が終了したときには、txidとともにあなたに通知されます。Tridentは、Stateの仕組み、それを更新する方法、状態の読み出しについてどんなメソッドがあるかについて、何も想定していません。</p>

<p>ユーザーの位置情報を含む自宅のデータベースがあり、それをTridentからアクセスできるようにしたいとします。Stateの実装には、ユーザー情報を取得して設定するメソッドがあります:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocationDB</span> <span class="kd">implements</span> <span class="n">State</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">beginCommit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">)</span> <span class="o">{</span>    
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">commit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">)</span> <span class="o">{</span>    
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLocation</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">,</span> <span class="n">String</span> <span class="n">location</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// code to access database and set location</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getLocation</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// code to get location from database</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>その後、Tridentタスク内でStateのインスタンスを作成できるStateFactoryをTridentに提供します。LocationDBのStateFactoryは次のようになります:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocationDBFactory</span> <span class="kd">implements</span> <span class="n">StateFactory</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="n">State</span> <span class="nf">makeState</span><span class="o">(</span><span class="n">Map</span> <span class="n">conf</span><span class="o">,</span> <span class="kt">int</span> <span class="n">partitionIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">numPartitions</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">LocationDB</span><span class="o">();</span>
   <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div>
<p>Tridentは、状態のソースにクエリするTrident操作を記述するQueryFunctionインターフェースと、状態のソースを更新するTrident操作を記述するためのStateUpdaterインターフェースを提供します。たとえば、LocationDBにユーザーの場所を照会する操作&quot;QueryLocation&quot;を作成します。トポロジでどのように使用するかについて説明しましょう。このトポロジが入力ストリームのユーザIDをコンシュームしているとします:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>
<span class="n">TridentState</span> <span class="n">locations</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="na">newStaticState</span><span class="o">(</span><span class="k">new</span> <span class="n">LocationDBFactory</span><span class="o">());</span>
<span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"myspout"</span><span class="o">,</span> <span class="n">spout</span><span class="o">)</span>
        <span class="o">.</span><span class="na">stateQuery</span><span class="o">(</span><span class="n">locations</span><span class="o">,</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"userid"</span><span class="o">),</span> <span class="k">new</span> <span class="n">QueryLocation</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"location"</span><span class="o">))</span>
</code></pre></div>
<p>次に、QueryLocationの実装がどのようになるかを見てみましょう:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QueryLocation</span> <span class="kd">extends</span> <span class="n">BaseQueryFunction</span><span class="o">&lt;</span><span class="n">LocationDB</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">batchRetrieve</span><span class="o">(</span><span class="n">LocationDB</span> <span class="n">state</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="nl">input:</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ret</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">getLocation</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">String</span> <span class="n">location</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">location</span><span class="o">));</span>
    <span class="o">}</span>    
<span class="o">}</span>
</code></pre></div>
<p>QueryFunctionは2つのステップで実行されます。まず、Tridentは読み取りのバッチをまとめてbatchRetrieveに渡します。この場合、batchRetrieveは複数のユーザーIDを受け取ります。batchRetrieveは、入力タプルのリストと同じサイズの結果のリストを返すことが期待されます。結果リストの最初の要素は、最初の入力タプルの結果に対応し、2番目の要素は2番目の入力タプルの結果に対応し、以下同様です。</p>

<p>前のコードは、Tridentが一度に1つずつLocationDBを照会するだけなので、Tridentが行うバッチ処理を利用していないことがわかります。だから、LocationDBを書くより良い方法は次のようになります:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocationDB</span> <span class="kd">implements</span> <span class="n">State</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">beginCommit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">)</span> <span class="o">{</span>    
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">commit</span><span class="o">(</span><span class="n">Long</span> <span class="n">txid</span><span class="o">)</span> <span class="o">{</span>    
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLocationsBulk</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">userIds</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">locations</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// set locations in bulk</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">bulkGetLocations</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">userIds</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// get locations in bulk</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>そうすると、次のようにQueryLocation関数を記述できます:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QueryLocation</span> <span class="kd">extends</span> <span class="n">BaseQueryFunction</span><span class="o">&lt;</span><span class="n">LocationDB</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">batchRetrieve</span><span class="o">(</span><span class="n">LocationDB</span> <span class="n">state</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">userIds</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="nl">input:</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">userIds</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">bulkGetLocations</span><span class="o">(</span><span class="n">userIds</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="n">tuple</span><span class="o">,</span> <span class="n">String</span> <span class="n">location</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">collector</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="k">new</span> <span class="n">Values</span><span class="o">(</span><span class="n">location</span><span class="o">));</span>
    <span class="o">}</span>    
<span class="o">}</span>
</code></pre></div>
<p>このコードは、データベースへのラウンドトリップを減らすことによって、はるかに効率的になります。</p>

<p>状態を更新するには、StateUpdaterインタフェースを使用します。以下に新しい位置情報でLocationDBを更新するStateUpdaterがあります:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocationUpdater</span> <span class="kd">extends</span> <span class="n">BaseStateUpdater</span><span class="o">&lt;</span><span class="n">LocationDB</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateState</span><span class="o">(</span><span class="n">LocationDB</span> <span class="n">state</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TridentTuple</span><span class="o">&gt;</span> <span class="n">tuples</span><span class="o">,</span> <span class="n">TridentCollector</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">ids</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">locations</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">TridentTuple</span> <span class="nl">t:</span> <span class="n">tuples</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ids</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
            <span class="n">locations</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="n">state</span><span class="o">.</span><span class="na">setLocationsBulk</span><span class="o">(</span><span class="n">ids</span><span class="o">,</span> <span class="n">locations</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Tridentトトポロジでこの操作を使用する方法は次のとおりです:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>
<span class="n">TridentState</span> <span class="n">locations</span> <span class="o">=</span> 
    <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"locations"</span><span class="o">,</span> <span class="n">locationsSpout</span><span class="o">)</span>
        <span class="o">.</span><span class="na">partitionPersist</span><span class="o">(</span><span class="k">new</span> <span class="n">LocationDBFactory</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"userid"</span><span class="o">,</span> <span class="s">"location"</span><span class="o">),</span> <span class="k">new</span> <span class="n">LocationUpdater</span><span class="o">())</span>
</code></pre></div>
<p>partitionPersist操作は、状態のソースを更新します。StateUpdaterはStateと、そのStateへの更新を伴うタプルのバッチを受け取ります。このコードは、入力タプルからユーザーIDとlocationを取得し、状態を一括して設定します。</p>

<p>partitionPersistは、Tridentのトポロジによって更新されるlocation dbを表すTridentStateオブジェクトを返します。この状態は、トポロジのどの場所でもstateQuery操作で使用できます。</p>

<p>StateUpdatersにはTridentCollectorが与えられていることもわかります。このコレクターにemitされたタプルは、&quot;new values stream&quot;に移動します。この場合、そのストリームにemitするのは特に興味深いことでありませんが、データベースのカウントを更新する場合などは、更新されたカウントをそのストリームにemitすることができます。その後、TridentState#newValuesStreamメソッドを使用して、新しい値ストリームにアクセスしてさらに処理することができます。</p>

<h2 id="persistentaggregate">persistentAggregate</h2>

<p>Tridentには、persistentAggregateという状態を更新する別の方法があります。これはストリーミングのワードカウントの例で使用されています:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TridentTopology</span> <span class="n">topology</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TridentTopology</span><span class="o">();</span>        
<span class="n">TridentState</span> <span class="n">wordCounts</span> <span class="o">=</span>
      <span class="n">topology</span><span class="o">.</span><span class="na">newStream</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="n">spout</span><span class="o">)</span>
        <span class="o">.</span><span class="na">each</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"sentence"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Split</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"word"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">persistentAggregate</span><span class="o">(</span><span class="k">new</span> <span class="n">MemoryMapState</span><span class="o">.</span><span class="na">Factory</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Count</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Fields</span><span class="o">(</span><span class="s">"count"</span><span class="o">))</span>
</code></pre></div>
<p>persistentAggregateは、Tridentのaggregatorを使用して状態のソースに更新を適用する方法を知っている、partitionPersistの上に構築された追加の抽象です。この場合、これはグループ化されたストリームなので、Tridentに渡されるstateが&quot;MapState&quot;インタフェースを実装していることが期待されます。グループ化フィールドは状態のキーになり、集計結果は状態のバリューになります。&quot;MapState&quot;インターフェースは次のようになります：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MapState</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">State</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">multiGet</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">);</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">multiUpdate</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ValueUpdater</span><span class="o">&gt;</span> <span class="n">updaters</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">multiPut</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vals</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>グループ化されていないストリーム(global aggregation)にアグリゲーションを実行すると、TridentはStateオブジェクトが&quot;Snapshottable&quot;インターフェイスを実装することを期待します。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Snapshottable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">State</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">get</span><span class="o">();</span>
    <span class="n">T</span> <span class="nf">update</span><span class="o">(</span><span class="n">ValueUpdater</span> <span class="n">updater</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p><a href="http://github.com/apache/storm/blob/1.x-branch/storm-core/src/jvm/org/apache/storm/trident/testing/MemoryMapState.java">MemoryMapState</a>や <a href="https://github.com/nathanmarz/trident-memcached/blob/1.0.2/src/jvm/trident/memcached/MemcachedState.java">MemcachedState</a>はそれぞれこれらの両方のインタフェースを実装しています。</p>

<h2 id="implementing-map-states">Implementing Map States</h2>

<p>TridentはMapStateの実装を容易にし、ほぼすべての作業を行います。OpaqueMapクラス、TransactionalMapクラス、およびNonTransactionalMapクラスは、それぞれのフォールトトレランスロジックを実行するためのすべてのロジックを実装します。これらのクラスに、それぞれのキー/バリューのmultiGetsとmultiPutsを行う方法を知っているIBackingMapの実装を提供するだけです。IBackingMapは次のようになります:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IBackingMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">multiGet</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">);</span> 
    <span class="kt">void</span> <span class="nf">multiPut</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">keys</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vals</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre></div>
<p>OpaqueMapは値に<a href="http://github.com/apache/storm/blob/1.x-branch/storm-core/src/jvm/org/apache/storm/trident/state/OpaqueValue.java">OpaqueValue</a>を指定してmultiPutを呼び出し、TransactionalMapは値に<a href="http://github.com/apache/storm/blob/1.x-branch/storm-core/src/jvm/org/apache/storm/trident/state/TransactionalValue.java">TransactionalValue</a>を指定し、NonTransactionalMapsはトポロジからオブジェクトを渡すだけです。</p>

<p>また、Tridentはマップのキー/バリューについて自動的にLRUキャッシングを行う<a href="http://github.com/apache/storm/blob/1.x-branch/storm-core/src/jvm/org/apache/storm/trident/state/map/CachedMap.java">CachedMap</a>クラスも提供します。</p>

<p>最後に、Tridentは<a href="http://github.com/apache/storm/blob/1.x-branch/storm-core/src/jvm/org/apache/storm/trident/state/map/SnapshottableMap.java">SnapshottableMap</a>クラスを提供し、グローバルな集約を固定キーに格納することでMapStateをSnapshottableオブジェクトに変換します。</p>

<p><a href="https://github.com/nathanmarz/trident-memcached/blob/master/src/jvm/trident/memcached/MemcachedState.java">MemcachedState</a>の実装を見て、MapStateの高性能実装を実現するためにこれらのユーティリティをどのように組み合わせるかを見てみましょう。MemcachedStateでは、opaque transactional, transactional, ならびに non-transactionalのセマンティクスを選択できます。</p>



	          </div>
	       </div>
	  </div>
<footer>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>Meetups</h5>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>About Storm</h5>
                    <p>Storm integrates with any queueing system and any database system. Storm's spout abstraction makes it easy to integrate a new queuing system. Likewise, integrating Storm with database systems is easy.</p>
               </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>First Look</h5>
                    <ul class="footer-list">
                        <li><a href="./Rationale.html">Rationale</a></li>
                        <li><a href="./Tutorial.html">Tutorial</a></li>
                        <li><a href="./Setting-up-development-environment.html">Setting up development environment</a></li>
                        <li><a href="./Creating-a-new-Storm-project.html">Creating a new Storm project</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-3">
                <div class="footer-widget">
                    <h5>Documentation</h5>
                    <ul class="footer-list">
                        <li><a href="./index.html">Index</a></li>
                        <li><a href="./javadocs/index.html">Javadoc</a></li>
                        <li><a href="./FAQ.html">FAQ</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <hr/>
        <div class="row">   
            <div class="col-md-12">
                <p align="center">Copyright © 2015 <a href="http://www.apache.org">Apache Software Foundation</a>. All Rights Reserved. 
                    <br>Apache Storm, Apache, the Apache feather logo, and the Apache Storm project logos are trademarks of The Apache Software Foundation. 
                    <br>All other marks mentioned may be trademarks or registered trademarks of their respective owners.</p>
            </div>
        </div>
    </div>
</footer>
<!--Footer End-->
<!-- Scroll to top -->
<span class="totop"><a href="#"><i class="fa fa-angle-up"></i></a></span> 

</body>

</html>

